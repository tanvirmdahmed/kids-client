import React, { useRef } from 'react';
import { useReactToPrint } from 'react-to-print';
import useTitle from '../../Hooks/useTitle';



const Blogs = () => {
    const componentRef = useRef();
    useTitle('Blogs');

    const handlePrint = useReactToPrint({
        content: () => componentRef.current,
    });

    const handleClick = () => {
        handlePrint();
    }

    return (
        <div className='w-full mb-5 px-3 md:px-0 lg:px-0'>
            <div ref={componentRef}>
                <div className='my-6'>
                    <h1 className='text-xl md:text-4xl lg:text-4xl text-center font-bold my-10'>Interview Questions Answers</h1>
                </div>
                <div>
                    <div className='bg-image rounded-lg px-4 md:px-12 lg:px-16 py-3 my-4'>
                        <p className='text-md md:text-2xl lg:text-2xl text-justify font-bold mb-4'>Q1. What is an access token and refresh token? How do they work and where should we store them on the client-side?</p>
                        <p className='text-sm md:text-lg lg:text-lg font-light text-justify mb-2'><strong className='font-bold'>Ans:</strong> An access token is a security token that is generated by an authentication server upon successful user authentication. It is typically a string of characters and contains information such as the user's identity and the permissions granted to them. Access tokens are used to authorize and authenticate requests to access protected resources, such as APIs or web services. They have a limited lifespan and typically expire after a short period, requiring the user to reauthenticate to obtain a new access token. A refresh token, on the other hand, is a longer-lived credential that is also issued by the authentication server during the initial authentication process. The refresh token is securely stored on the client-side, usually in a cookie or local storage. When an access token expires, the client can use the refresh token to request a new access token from the authentication server, without requiring the user to re-enter their credentials. This process is known as a token refresh or token renewal. Refresh tokens have a longer lifespan compared to access tokens and are used to obtain new access tokens when needed. To ensure security, access tokens should be stored securely on the client-side, typically in memory or a secure storage mechanism provided by the platform or framework being used. Refresh tokens, on the other hand, should never be accessible from the client-side code or exposed to potential attackers. They should be securely stored and transmitted over encrypted channels, such as using HTTP-only cookies or server-side sessions. By storing refresh tokens securely, the risk of unauthorized access and misuse of tokens is minimized.</p>
                    </div>
                    <div className='bg-image rounded-lg px-4 md:px-12 lg:px-16 py-3 my-4'>
                        <p className='text-md md:text-2xl lg:text-2xl text-justify font-bold mb-4'>Q2. Compare SQL and NoSQL databases?</p>
                        <p className='text-sm md:text-lg lg:text-lg font-light text-justify'><strong className='font-bold'>Ans:</strong> SQL databases use a structured data model where data is organized into tables with predefined schemas. They enforce a rigid structure, with data relationships established through foreign keys. SQL databases, such as MySQL and PostgreSQL, are best suited for applications with fixed schemas and complex relationships between data entities. They provide ACID (Atomicity, Consistency, Isolation, Durability) compliance, ensuring data integrity. On the other hand, NoSQL databases offer a more flexible data model that can handle unstructured or semi-structured data. NoSQL databases, such as MongoDB and Cassandra, support various data models like key-value, document, columnar, and graph. They allow for dynamic and scalable schemas, making them ideal for handling large volumes of data with evolving requirements. NoSQL databases prioritize horizontal scalability by distributing data across multiple servers or clusters, which enables them to handle high traffic and large datasets. In summary, SQL databases provide a structured and rigid approach with strong data consistency guarantees, while NoSQL databases offer flexibility, scalability, and better performance for handling diverse and rapidly changing data. The choice between the two depends on the specific needs and characteristics of the application or project.</p>
                    </div>
                    <div className='bg-image rounded-lg px-4 md:px-12 lg:px-16 py-3 my-4'>
                        <p className='text-md md:text-2xl lg:text-2xl text-justify font-bold mb-4'>Q3. What is express js? What is Nest JS?</p>
                        <p className='text-sm md:text-lg lg:text-lg font-light text-justify'><strong className='font-bold'>Ans:</strong> Express.js is a minimalistic and flexible web application framework for Node.js. It provides a simple and straightforward way to build web applications and APIs by offering a set of robust features and middleware. Express.js is known for its lightweight and unopinionated nature, allowing developers to have more control over the application's architecture and design. NestJS, on the other hand, is a progressive and opinionated Node.js framework for building scalable and efficient server-side applications. It is built with TypeScript and takes advantage of decorators, dependency injection, and modular architecture patterns to enhance code organization and maintainability. NestJS follows a similar structure and syntax as Angular, making it easier for developers familiar with Angular to transition to server-side development. It also provides built-in support for features like dependency injection, routing, and middleware integration, making it suitable for building complex and enterprise-grade applications.</p>
                    </div>
                    <div className='bg-image rounded-lg px-4 md:px-12 lg:px-16 py-3 my-4'>
                        <p className='text-md md:text-2xl lg:text-2xl text-justify font-bold mb-4'>Q4. What is MongoDB aggregate and how does it work?</p>
                        <p className='text-sm md:text-lg lg:text-lg font-light text-justify'><strong className='font-bold'>Ans:</strong> MongoDB's aggregate is a powerful framework that allows you to perform advanced data processing and analysis operations on collections of documents within a MongoDB database. It provides a way to extract, transform, and aggregate data using a pipeline of stages. The aggregation pipeline consists of multiple stages, each representing a specific operation. These stages can include filtering, grouping, sorting, projecting, and performing various calculations on the data. When you execute an aggregate operation, MongoDB processes the documents in the collection through the pipeline stages in sequence. At each stage, the input documents are transformed according to the specified operation, and the resulting documents are passed to the next stage. The stages are highly flexible and can be combined in various ways to achieve complex data transformations. The aggregation pipeline supports a wide range of operators and expressions, allowing you to perform operations like grouping documents, performing arithmetic calculations, joining collections, and more. By leveraging the aggregate framework, you can perform advanced data analysis tasks directly within the database, reducing the need to transfer and process large amounts of data in client applications. This can improve performance and simplify your application code. Overall, MongoDB's aggregate is a versatile and efficient tool for data aggregation and analysis, providing a declarative and pipeline-based approach to process and transform your data.</p>
                    </div>
                </div>
            </div>
            <div className='text-center'>
                <button onClick={handleClick} className='btn btn-outline'>Download PDF</button>
            </div>
        </div>
    );
};

export default Blogs;